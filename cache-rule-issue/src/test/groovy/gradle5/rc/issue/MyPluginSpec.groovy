/*
 * This Spock specification was generated by the Gradle 'init' task.
 */
package gradle5.rc.issue

import com.google.common.base.Function
import com.google.common.base.Predicate
import com.google.common.collect.FluentIterable
import nebula.test.IntegrationSpec
import nebula.test.dependencies.DependencyGraphBuilder
import nebula.test.dependencies.GradleDependencyGenerator
import nebula.test.dependencies.ModuleBuilder
import nebula.test.functional.GradleRunner
import org.gradle.internal.classloader.ClasspathUtil
import org.gradle.internal.classpath.ClassPath
import org.gradle.util.TextUtil
import spock.lang.Unroll

class MyPluginSpec extends IntegrationSpec {
    def setup() {
        def initScript = new File(projectDir, "init.gradle")
        initScript.text = """
            import static gradle5.rc.issue.MyPlugin.defineStatuses
            import static gradle5.rc.issue.StatusAttribute.configureStatusAttribute
            
            initscript {
                dependencies {
                   ${buildDependencies()}
                }
            }
            
            allprojects {
                configureStatusAttribute(it)
                buildscript {
                    defineStatuses(dependencies)
                }
            } 
        """
        addInitScript(initScript)
    }

    def "specific transitive candidates or snapshots resolved"() {
        given:
        def graph = new DependencyGraphBuilder()
                .addModule('test.nebula:a:1.0.0')
                .addModule('test.nebula:a:1.1.0')
                .addModule(new ModuleBuilder('test.nebula:a:1.1.1-rc.1')
                .addDependency('test.nebula:c:1.1.1-rc.1').build())
                .addModule(new ModuleBuilder('test.nebula:c:1.1.1-rc.1')
                .addDependency('test.nebula:d:1.1.1-rc.1').build())
                .addModule('test.nebula:b:1.0.0')
                .addModule('test.nebula:b:1.0.1')
                .addModule(new ModuleBuilder('test.nebula:b:1.2.0-rc.1')
                .addDependency('test.nebula:c:1.1.1-rc.1').build())
                .build()
        def mavenrepo = new GradleDependencyGenerator(graph, "${projectDir}/testrepogen")
        mavenrepo.generateTestMavenRepo()

        buildFile << """  
            buildscript {               
                repositories {
                    ${mavenrepo.mavenRepositoryBlock}
                }
                dependencies {
                    classpath 'test.nebula:a:1.1.1-rc.1', {
                            attributes { attribute(org.gradle.api.internal.project.ProjectInternal.STATUS_ATTRIBUTE, 'candidate') }
                    }
                    classpath 'test.nebula:b:latest.candidate', {
                            attributes { attribute(org.gradle.api.internal.project.ProjectInternal.STATUS_ATTRIBUTE, 'candidate') }
                    }
                }
            }

            apply plugin: gradle5.rc.issue.MyPlugin
        """.stripIndent()


        when:
        def result = runTasksSuccessfully("build", "--build-cache")

        then:
        result.standardOutput.contains("test.nebula:c:1.1.1-rc.1")

        and:
        result.standardOutput.contains("Executing CacheableStatusRule")

        when:
        def result2 = runTasksSuccessfully("build", "--build-cache")

        then:
        !result2.standardOutput.contains("Executing CacheableStatusRule")

    }


    static String buildDependencies() {
        ClassLoader classLoader = MyPluginSpec.class.getClassLoader()
        def classpathFilter = GradleRunner.CLASSPATH_DEFAULT
        getClasspathAsFiles(classLoader, classpathFilter).collect {
            String.format("      classpath files('%s')\n", TextUtil.escapeString(it.getAbsolutePath()))
        }.join('\n')
    }

    private static List<File> getClasspathAsFiles(ClassLoader classLoader, Predicate<URL> classpathFilter) {
        List<URL> classpathUrls = getClasspathUrls(classLoader)
        return FluentIterable.from(classpathUrls).filter(classpathFilter).transform(new Function<URL, File>() {
            @Override
            File apply(URL url) {
                return new File(url.toURI())
            }
        }).toList()
    }

    private static List<URL> getClasspathUrls(ClassLoader classLoader) {
        Object cp = ClasspathUtil.getClasspath(classLoader)
        if (cp instanceof List<URL>) {
            return (List<URL>) cp
        }
        if (cp instanceof ClassPath) {
            return ((ClassPath) cp).asURLs
        }
        throw new IllegalStateException("Unable to extract classpath urls from type ${cp.class.canonicalName}")
    }
}